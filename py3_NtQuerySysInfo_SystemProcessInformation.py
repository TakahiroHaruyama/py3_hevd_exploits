import sys

from ctypes import *
from ctypes.wintypes import *


# Windows Common Data Types
NTSTATUS = DWORD
PHANDLE = POINTER(HANDLE)
PVOID = LPVOID = ULONG_PTR = c_void_p
#KPRIORITY = LONG
KPRIORITY = c_longlong
LARGE_INTEGER = c_longlong
QWORD = c_ulonglong

# Structures
'''
class (Structure):
    _fields_ = [
        ("", ),
    ]
'''

class CLIENT_ID(Structure):
    _fields_ = [
        ("UniqueProcess", DWORD),
        ("UniqueThread", DWORD),
    ]

class UNICODE_STRING(Structure):
    _fields_ = [
        ("Length", USHORT),
        ("MaximumLength", USHORT),
        ("Buffer", LPWSTR)
    ]

class VM_COUNTERS(Structure):
    _fields_ = [
        ("PeakVirtualSize", QWORD),
        ("PageFaultCount", QWORD),
        ("PeakWorkingSetSize", QWORD),
        ("WorkingSetSize", QWORD),
        ("QuotaPeakPagedPoolUsage", QWORD),
        ("QuotaPagedPoolUsage", QWORD),
        ("QuotaPeakNonPagedPoolUsage", QWORD),
        ("QuotaNonPagedPoolUsage", QWORD),
        ("PagefileUsage", QWORD),
        ("PeakPagefileUsage", QWORD),
        ("VirtualSize", QWORD)
    ]

class IO_COUNTERS(Structure):
    _fields_ = [
        ("ReadOperationCount", QWORD),
        ("WriteOperationCount", QWORD),
        ("OtherOperationCount", QWORD),
        ("ReadTransferCount", QWORD),
        ("WriteTransferCount", QWORD),
        ("OtherTransferCount", QWORD)
    ]
    
class SYSTEM_THREAD_INFORMATION(Structure):
    _fields_ = [
        ("KernelTime", LARGE_INTEGER),
        ("UserTime", LARGE_INTEGER),
        ("CreateTime", LARGE_INTEGER),
        ("WaitTime", ULONG),
        ("StartAddress", PVOID),
        ("ClientId", CLIENT_ID),
        ("Priority", KPRIORITY),
        ("BasePriority", LONG),
        ("ContextSwitchCount", ULONG),
        ("ThreadState", ULONG),
        ("WaitReason", ULONG),
        ("Reserved", ULONG * 4)
    ]

class SYSTEM_EXTENDED_THREAD_INFORMATION(Structure):
    _fields_ = [
        ("ThreadInfo", SYSTEM_THREAD_INFORMATION),
        ("StackBase", PVOID),
        ("StackLimit", PVOID),
        ("Win32StartAddress", PVOID),
        ("TebAddress", PVOID),
        ("Reserved1", ULONG),
        ("Reserved2", ULONG),
        ("Reserved3", ULONG)
    ]

class SYSTEM_EXTENDED_PROCESS_INFORMATION(Structure):
    _fields_ = [
        ("NextEntryOffset", ULONG),
        ("NumberOfThreads", ULONG),
        ("SpareLi1", LARGE_INTEGER),
        ("SpareLi2", LARGE_INTEGER),
        ("SpareLi3", LARGE_INTEGER),
        ("CreateTime", LARGE_INTEGER),
        ("UserTime", LARGE_INTEGER),
        ("KernelTime", LARGE_INTEGER),
        ("ImageName", UNICODE_STRING),
        ("BasePriority", KPRIORITY),
        ("ProcessId", ULONG),
        ("InheritedFromUniqueProcessId", ULONG),
        ("HandleCount", ULONG),
        ("SessionId", ULONG),
        ("PageDirectoryBase", PVOID),
        ("VirtualMemoryCounters", VM_COUNTERS),
        ("PrivatePageCount", PVOID),
        ("IoCounters", IO_COUNTERS),
        ("Threads", SYSTEM_EXTENDED_THREAD_INFORMATION * 1)
    ]

# Functions proxy
ntdll = windll.ntdll
kernel32 = windll.kernel32

# Functions

# void WINAPI OutputDebugString(
#   _In_opt_ LPCTSTR lpOutputString
# );
kernel32.OutputDebugStringA.argtypes = [LPCSTR]

# DWORD WINAPI GetCurrentProcessId(void);
kernel32.GetCurrentProcessId.restype = DWORD

# NTSTATUS WINAPI NtQuerySystemInformation(
#   _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
#   _Inout_   PVOID                    SystemInformation,
#   _In_      ULONG                    SystemInformationLength,
#   _Out_opt_ PULONG                   ReturnLength
# );
ntdll.NtQuerySystemInformation.argtypes = [DWORD, POINTER(SYSTEM_EXTENDED_PROCESS_INFORMATION), ULONG, POINTER(ULONG)]
ntdll.NtQuerySystemInformation.restype = NTSTATUS


'''

'''

# Constants
STATUS_SUCCESS = 0
STATUS_INFO_LENGTH_MISMATCH = 0xC0000004
STATUS_INVALID_HANDLE = 0xC0000008
SystemExtendedProcessInformation = 57


def debug_print(message):
    print(message)
    kernel32.OutputDebugStringA(message.encode() + b"\n")


def debug_break():
    """
    void WINAPI DebugBreak(void);
    """
    kernel32.DebugBreak()


def get_current_pid():
    return kernel32.GetCurrentProcessId()


def get_process_information(current_pid):
    system_ext_process_info = SYSTEM_EXTENDED_PROCESS_INFORMATION()
    size = DWORD(sizeof(system_ext_process_info))

    while True:
        result = ntdll.NtQuerySystemInformation(
            SystemExtendedProcessInformation,
            byref(system_ext_process_info),
            size,
            byref(size)
        )
        if result == STATUS_SUCCESS:
            break
        elif result == STATUS_INFO_LENGTH_MISMATCH:
            size = DWORD(size.value * 4)
            resize(system_ext_process_info, size.value)
        else:
            raise Exception("NtQuerySystemInformation error: {0}".format(hex(result)))
        
    while True:
        if system_ext_process_info.ProcessId == current_pid: # silently exit here when importing this script?
            debug_print('process ID = {}, ImageName = {}'.format(system_ext_process_info.ProcessId,
                                                                 system_ext_process_info.ImageName.Buffer))
            break
        if system_ext_process_info.NextEntryOffset:
            #debug_print('pinfo ptr = {:#x}'.format(addressof(system_ext_process_info)))
            #debug_print('next offset = {:#x}'.format(system_ext_process_info.NextEntryOffset))
            p_next = cast(addressof(system_ext_process_info) + system_ext_process_info.NextEntryOffset,
                          POINTER(SYSTEM_EXTENDED_PROCESS_INFORMATION))
            #debug_break()
            #input("Press any key to continue...")
            system_ext_process_info = p_next.contents
        else:
            raise Exception("The current process structure not found")

    #debug_print('number of threads = {}'.format(system_ext_process_info.NumberOfThreads))
    p_threads = cast(system_ext_process_info.Threads,
                     POINTER(SYSTEM_EXTENDED_THREAD_INFORMATION * system_ext_process_info.NumberOfThreads))
    res = []    
    for thread in p_threads.contents:
        debug_print('StackBase = {:#x}, StackLimit = {:#x}'.format(thread.StackBase, thread.StackLimit))
        debug_print('Win32StartAddress = {:#x}, TebAddress = {:#x}'.format(thread.Win32StartAddress, thread.TebAddress))
        res.append((thread.StackLimit, thread.StackBase))
    
    return res
        

if __name__ == "__main__":
    current_pid = get_current_pid()
    get_process_information(current_pid)
    
